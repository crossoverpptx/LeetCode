# 1. Two Sum

这道题给了我们一个数组，还有一个目标数target，让找到两个数字，使其和为target。

乍一看就感觉可以用暴力搜索，但是猜到OJ肯定不会允许用暴力搜索这么简单的方法，果然是Time Limit Exceeded，这个算法的时间复杂度是O(n^2)。

那么只能想个O(n)的算法来实现，由于暴力搜索的方法是遍历所有的两个数字的组合，然后算其和，这样虽然节省了空间，但是时间复杂度高。一般来说，为了提高时间的复杂度，需要用空间来换，这算是一个trade off吧，但这里只想用线性的时间复杂度来解决问题，就是说只能遍历一个数字，那么另一个数字呢，可以事先将其存储起来，使用一个HashMap，来建立数字和其坐标位置之间的映射，由于HashMap是常数级的查找效率，这样在遍历数组的时候，用target减去遍历到的数字，就是另一个需要的数字了，直接在HashMap中查找其是否存在即可，注意要判断查找到的数字不是第一个数字，比如target是4，遍历到了一个2，那么另外一个2不能是之前那个2，整个实现步骤为：先遍历一遍数组，建立HashMap映射，然后再遍历一遍，开始查找，找到则记录index。

 C++ 解法一：

```c++
#include <iostream>
#include <vector>
#include <unordered_map>

using std::vector; using std::unordered_map; using std::pair; using std::allocator; using std::cout;

class Solution {
public:
	vector<int> twoSum(vector<int>& nums, int target) 
	{
		unordered_map<int, int> numsMap;
		vector<int> res;
		for (int i = 0; i < nums.size(); ++i)
		{
			numsMap.insert(pair<int, int>(nums[i], i));
			//Method 2
			//numsMap[nums[i]] = i;
		}
		for (int i = 0; i < nums.size(); ++i)
		{
			auto iter = numsMap.find(target - nums[i]);
			if (iter != numsMap.end() && iter->second != i) 
			{
				res.push_back(i);
				res.push_back(iter->second);
				return res;
			}
			//Method 2
			//int t = target - nums[i];
			//if (numsMap.count(t) && numsMap[t] != i)
			//{
			//	res.push_back(i);
			//	res.push_back(numsMap[t]);
			//	break;
			//}
		}
		return res;
	}
};

int main()
{
	int ai[4] = { 4, 3, 7, 32 };
	vector<int, allocator<int>> nums(ai, ai + 4);
	//Method 2
	//vector<int> nums = { 4, 3, 7, 32 };
	int target = 10;
	Solution s;
	vector<int> result = s.twoSum(nums, target);
	for (vector<int>::iterator it = result.begin(); it != result.end(); ++it)
		cout << *it << " ";
	return 0;
}
```

